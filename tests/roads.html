<html>
    <head>
        <title>Roads</title>
        <script src="https://unpkg.com/osmtogeojson/osmtogeojson.js"></script>
    </head>
    <body>
        <div id="map"></div>
        <!-- <script src="play0.js"></script> -->
        <script type="module">
            import util from '../src/util.js'
            import gis from '../src/gis.js'
            import World from '../src/World.js'
            import Model from '../src/Model.js'
            import Color from '../src/Color.js'
            // import ColorMap from '../src/ColorMap.js'
            import ThreeView from '../src/ThreeView.js'
            // import osmtogeojson from '../dist/osmtogeojson.esm.js'
            // import osmtogeojson from '../dist/osmtogeojson.esm.js'
            util.toWindow({ util, gis, World, Color, ThreeView, osmtogeojson })

            async function run() {
                const model = new RoadsModel(World.defaultWorld(100))
                await model.startup()
                model.setup()

                const view = new ThreeView(document.body, model.world)
                const { Z, X, Y } = model.tile
                // osm is slooooow!
                // const baseUrl = `https://tile.openstreetmap.org/${Z}/${X}/${Y}.png`
                const baseUrl = `https://api.maptiler.com/maps/streets/${Z}/${X}/${Y}.png?key=iQurAP6lArV1UP4gfSVs`

                const baseMapTile = await util.imagePromise(baseUrl)
                const colors25 = util.repeat(25, (i, a) => {
                    a[i] = Color.randomTypedColor().webgl
                })

                util.toWindow({ model, view, baseMapTile, colors25 })
                // const { patches, turtles, links } = model
                // util.toWindow({ patches, turtles, links })

                // Object.assign(window, model)

                view.installDrawing(baseMapTile)
                view.drawTurtles(model.turtles, t => ({
                    sprite: view.getSprite('circle', 'red'),
                    size: t.links.length > 2 ? 1 : 0.5,
                }))
                view.drawLinks(model.links, l => ({
                    color: colors25[l.lineString.properties.featureIndex % 25],
                }))
                view.draw()
                view.idle()
            }

            class RoadsModel extends Model {
                static defaults() {
                    return {
                        tile: { Z: 14, X: 3370, Y: 6451 },
                        // jsonUrl: './14.3370.6451.json',
                    }
                }

                // ======================

                constructor(worldDptions) {
                    super(worldDptions)
                    Object.assign(this, RoadsModel.defaults())
                    this.nodeCache = {}
                }

                async startup() {
                    // const { Z, X, Y } = this.tile

                    // this.jsonUrl = `./${Z}.${X}.${Y}.json`
                    // this.jsonUrl = `./${Z}.${X}.${Y}.mvt.json`
                    // this.jsonUrl = `./${Z}.${X}.${Y}.json`
                    this.jsonUrl = '../models/santafe.json'
                    const json = await util.xhrPromise(this.jsonUrl)
                    this.geojson = JSON.parse(json)
                }

                getNode(pt) {
                    const key = pt.toString()
                    let node = this.nodeCache[key]
                    if (node) return node

                    node = this.turtles.create(1, t => {
                        t.setxy(...this.xfm.toWorld(pt))
                    })
                    this.nodeCache[key] = node
                    return node
                }
                newLink(pt0, pt1) {
                    const t0 = this.getNode(pt0)
                    const t1 = this.getNode(pt1)
                    return this.links.create(t0, t1)
                }
                lineStringToLinks(lineString) {
                    // const lineLinks =
                    lineString.reduce((acc, pt, i, a) => {
                        // const link = [a[i - 1], pt]
                        const link = this.newLink(a[i - 1], pt)
                        if (i === 1) {
                            acc = [link]
                            acc.properties = lineString.properties
                        } else {
                            acc.push(link)
                        }
                        link.lineString = acc
                        return acc
                    })
                    // lineLinks.forEach(link => link.)
                }
                setup() {
                    this.turtles.setDefault('atEdge', 'OK')

                    const { Z, X, Y } = this.tile
                    this.bbox = gis.xy2bbox(X, Y, Z)
                    this.xfm = this.world.bboxTransform(...this.bbox)
                    console.log('bbox size', gis.lonLat2meters(...this.bbox))

                    const features = this.geojson.features
                    // note index is shared amongst the MultiLineStrings
                    features.forEach((obj, i) => {
                        obj.properties.featureIndex = i
                        obj.properties.featureID = obj.id
                    })

                    this.lineStrings = features.reduce((acc, obj, i) => {
                        const geom = obj.geometry
                        if (geom.type === 'LineString') {
                            geom.coordinates.properties = obj.properties
                            acc.push(geom.coordinates)
                        } else if (geom.type === 'MultiLineString') {
                            geom.coordinates.forEach(a => {
                                a.properties = obj.properties
                                acc.push(a)
                            })
                        }
                        return acc
                    }, [])

                    this.lineStrings.forEach(lineString =>
                        this.lineStringToLinks(lineString)
                    )

                    // this.points = this.lineStrings.reduce((acc, line, i) => {
                    //     line.forEach(pt => {
                    //         pt.properties = line.properties
                    //         pt.lineIndex = i
                    //     })
                    //     return acc.concat(line)
                    // }, [])

                    // // points.forEach(p => console.log(...p, p.lineIndex))

                    // const lonlats = {}
                    // this.points.forEach(p => {
                    //     // const lonlat = p.toString()
                    //     // if (lonlats[lonlat])
                    //     this.turtles.create(1, t => {
                    //         const pt = this.xfm.toWorld(p)
                    //         t.setxy(...pt)
                    //     })
                    // })
                }
            }

            run().then(() => console.log('done'))

            // this.lineLinks = this.lineStrings.reduce(
            //     (acc, val, i, a) => {
            //         const pt = [val, a[i - 1]]
            //         console.log(acc, val, i, pt)
            //         if (i === 1) {
            //             return [pt]
            //         } else {
            //             acc.push(pt)
            //             return acc
            //         }
            //     }
            // )
            // this.links = this.lineStrings.reduce(
            //     (acc, strip, i) => [acc[acc.length - 1]],
            //     []
            // )
            // this.lineStrings = this.geojson.features.reduce((acc, obj) => {
            //     const geom = obj.geometry
            //     if (geom.type === 'LineString') {
            //         acc.push(geom.coordinates)
            //     } else if (geom.type === 'MultiLineString') {
            //         geom.coordinates.forEach(a => acc.push(a))
            //     }
            //     return acc
            // }, [])

            // this.points = this.lineStrings.reduce(
            //     (acc, line) => acc.concat(line),
            //     []
            // )
        </script>
    </body>
</html>
