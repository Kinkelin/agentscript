(function(global,factory){typeof exports==="object"&&typeof module!=="undefined"?factory(exports):typeof define==="function"&&define.amd?define(["exports"],factory):factory(global.AS={})})(this,function(exports){"use strict";function createCanvas(width=0,height=0,offscreen=true){if(offscreen)return new OffscreenCanvas(width,height);const can=document.createElement("canvas");can.width=width;can.height=height;return can}function createCtx(width,height,offscreen=true){const can=createCanvas(width,height,offscreen);return can.getContext("2d")}function cloneCanvas(can,offscreen=true){const ctx=createCtx(can.width,can.height,offscreen);ctx.drawImage(can,0,0);return ctx.canvas}function resizeCtx(ctx,width,height){const copy=cloneCanvas(ctx.canvas);ctx.canvas.width=width;ctx.canvas.height=height;ctx.drawImage(copy,0,0)}function setCanvasSize(can,width,height){if(can.width!==width||can.height!=height){can.width=width;can.height=height}}function setIdentity(ctx){ctx.save();ctx.setTransform(1,0,0,1,0,0)}function setTextParams(ctx,font,textAlign="center",textBaseline="middle"){Object.assign(ctx,{font:font,textAlign:textAlign,textBaseline:textBaseline})}function ctxImageData(ctx){return ctx.getImageData(0,0,ctx.canvas.width,ctx.canvas.height)}function clearCtx(ctx){setIdentity(ctx);ctx.clearRect(0,0,ctx.canvas.width,ctx.canvas.height);ctx.restore()}function fillCtx(ctx,cssColor){setIdentity(ctx);ctx.fillStyle=cssColor;ctx.fillRect(0,0,ctx.canvas.width,ctx.canvas.height);ctx.restore()}function fillCtxWithImage(ctx,img){setIdentity(ctx);ctx.drawImage(img,0,0,ctx.canvas.width,ctx.canvas.height);ctx.restore()}function setCtxImage(ctx,img){setCanvasSize(ctx.canvas,img.width,img.height);fillCtxWithImage(ctx,img)}const imageToBytesCtx=null;function imageToBytes(img,flipY=false,imgFormat="RGBA"){if(!imageToBytesCtx){const can=createCanvas(0,0);imageToBytesCtx=can.getContext("webgl",{premultipliedAlpha:false})}const{width:width,height:height}=img;const gl=imageToBytesCtx;Object.assign(gl.canvas,{width:width,height:height});const fmt=gl[imgFormat];const texture=gl.createTexture();gl.bindTexture(gl.TEXTURE_2D,texture);if(flipY){gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL,true)}gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL,gl.NONE);gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,false);gl.texImage2D(gl.TEXTURE_2D,0,fmt,fmt,gl.UNSIGNED_BYTE,img);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.NEAREST);gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.NEAREST);const framebuffer=gl.createFramebuffer();gl.bindFramebuffer(gl.FRAMEBUFFER,framebuffer);gl.framebufferTexture2D(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0,gl.TEXTURE_2D,texture,0);const status=gl.checkFramebufferStatus(gl.FRAMEBUFFER);if(status!==gl.FRAMEBUFFER_COMPLETE){throw Error(`imageToBytes: status not FRAMEBUFFER_COMPLETE: ${status}`)}const pixSize=imgFormat==="RGB"?3:4;const pixels=new Uint8Array(pixSize*width*height);gl.readPixels(0,0,width,height,fmt,gl.UNSIGNED_BYTE,pixels);gl.bindFramebuffer(gl.FRAMEBUFFER,null);return pixels}var canvas=Object.freeze({createCanvas:createCanvas,createCtx:createCtx,cloneCanvas:cloneCanvas,resizeCtx:resizeCtx,setCanvasSize:setCanvasSize,setIdentity:setIdentity,setTextParams:setTextParams,ctxImageData:ctxImageData,clearCtx:clearCtx,fillCtx:fillCtx,fillCtxWithImage:fillCtxWithImage,setCtxImage:setCtxImage,imageToBytes:imageToBytes});const typeOf=obj=>({}).toString.call(obj).match(/\s(\w+)/)[1].toLowerCase();const isType=(obj,string)=>typeOf(obj)===string;const isOneOfTypes=(obj,array)=>array.includes(typeOf(obj));const isString=obj=>isType(obj,"string");const isObject=obj=>isType(obj,"object");const isArray=obj=>isType(obj,"array");const isNumber=obj=>isType(obj,"number");const isFunction=obj=>isType(obj,"function");const isInteger=n=>Number.isInteger(n);const isFloat=n=>isNumber(n)&&n%1!==0;const isCanvas=obj=>isOneOfTypes(obj,["htmlcanvaselement","offscreencanvas"]);const isImageable=obj=>isOneOfTypes(obj,["image","htmlimageelement","htmlcanvaselement","offscreencanvas","imagebitmap"]);const isTypedArray=obj=>typeOf(obj.buffer)==="arraybuffer";const isUintArray=obj=>/^uint.*array$/.test(typeOf(obj));const isIntArray=obj=>/^int.*array$/.test(typeOf(obj));const isFloatArray=obj=>/^float.*array$/.test(typeOf(obj));function isLittleEndian(){const d32=new Uint32Array([16909060]);return new Uint8ClampedArray(d32.buffer)[0]===4}function convertArrayType$1(array,Type){const Type0=array.constructor;if(Type0===Type)return array;return Type.from(array)}var types=Object.freeze({typeOf:typeOf,isType:isType,isOneOfTypes:isOneOfTypes,isString:isString,isObject:isObject,isArray:isArray,isNumber:isNumber,isFunction:isFunction,isInteger:isInteger,isFloat:isFloat,isCanvas:isCanvas,isImageable:isImageable,isTypedArray:isTypedArray,isUintArray:isUintArray,isIntArray:isIntArray,isFloatArray:isFloatArray,isLittleEndian:isLittleEndian,convertArrayType:convertArrayType$1});function randomSeedSin(seed=Math.PI/4){return()=>{const x=Math.sin(seed++)*1e4;return x-Math.floor(x)}}function randomSeedParkMiller(seed=123456){seed=seed%2147483647;return()=>{seed=seed*16807%2147483647;return(seed-1)/2147483646}}function randomSeed(seed,useParkMiller=true){Math.random=useParkMiller?randomSeedParkMiller(seed):randomSeedSin(seed)}let logOnceMsgSet;function logOnce(msg){if(!logOnceMsgSet)logOnceMsgSet=new Set;if(!logOnceMsgSet.has(msg)){console.log(msg);logOnceMsgSet.add(msg)}}function warn(msg){logOnce("Warning: "+msg)}function printToPage(msg,element=document.body){if(isObject(msg)){msg=JSON.stringify(msg,null,2);msg="<pre>"+msg+"</pre>"}element.style.fontFamily="monospace";element.innerHTML+=msg+"<br />"}function timeit(f,runs=1e5,name="test"){name=name+"-"+runs;console.time(name);for(let i=0;i<runs;i++)f(i);console.timeEnd(name)}function fps(){const start=performance.now();let steps=0;function perf(){steps++;const ms=performance.now()-start;const fps=parseFloat((steps/(ms/1e3)).toFixed(2));Object.assign(perf,{fps:fps,ms:ms,start:start,steps:steps})}perf.steps=0;return perf}function pps(obj,title=""){if(title)console.log(title);let count=1;let str="";while(obj){if(typeof obj==="function"){str=obj.constructor.toString()}else{const okeys=Object.keys(obj);str=okeys.length>0?`[${okeys.join(", ")}]`:`[${obj.constructor.name}]`}console.log(`[${count++}]: ${str}`);obj=Object.getPrototypeOf(obj)}}function toWindow(obj,logToo=false){Object.assign(window,obj);console.log("toWindow:",Object.keys(obj).join(", "));if(logToo){Object.keys(obj).forEach(key=>console.log("  ",key,obj[key]))}}var debug=Object.freeze({randomSeedSin:randomSeedSin,randomSeedParkMiller:randomSeedParkMiller,randomSeed:randomSeed,logOnce:logOnce,warn:warn,printToPage:printToPage,timeit:timeit,fps:fps,pps:pps,toWindow:toWindow});const randomInt=max=>Math.floor(Math.random()*max);const randomInt2=(min,max)=>min+Math.floor(Math.random()*(max-min));const randomFloat=max=>Math.random()*max;const randomFloat2=(min,max)=>min+Math.random()*(max-min);const randomCentered=r=>randomFloat2(-r/2,r/2);function randomNormal(mean=0,sigma=1){const[u1,u2]=[1-Math.random(),Math.random()];const norm=Math.sqrt(-2*Math.log(u1))*Math.cos(2*Math.PI*u2);return norm*sigma+mean}const isPowerOf2=num=>(num&num-1)===0;const nextPowerOf2=num=>Math.pow(2,Math.ceil(Math.log2(num)));const mod=(v,n)=>(v%n+n)%n;const wrap=(v,min,max)=>min+mod(v-min,max-min);function clamp(v,min,max){if(v<min)return min;if(v>max)return max;return v}const between=(val,min,max)=>min<=val&&val<=max;const lerp$1=(lo,hi,scale)=>lo<=hi?lo+(hi-lo)*scale:lo-(lo-hi)*scale;const lerpScale=(number,lo,hi)=>(number-lo)/(hi-lo);const radians=degrees=>degrees*Math.PI/180;const degrees=radians=>radians*180/Math.PI;function heading(radians){const deg=degrees(radians);return mod(90-deg,360)}function angle(heading){const degrees=mod(360-heading,360);return radians(degrees)}function subtractRadians(rad1,rad0){let dr=mod(rad1-rad0,2*Math.PI);if(dr>Math.PI)dr=dr-2*Math.PI;return dr}function subtractHeadings(deg1,deg0){let dAngle=mod(deg1-deg0,360);if(dAngle>180)dAngle=dAngle-360;return dAngle}const radiansToward=(x,y,x1,y1)=>Math.atan2(y1-y,x1-x);function headingToward(x,y,x1,y1){return heading(radiansToward(x,y,x1,y1))}const distance=(x,y,x1,y1)=>Math.sqrt(sqDistance(x,y,x1,y1));const sqDistance=(x,y,x1,y1)=>(x-x1)*(x-x1)+(y-y1)*(y-y1);function inCone(x,y,radius,coneAngle,direction,x0,y0){if(sqDistance(x0,y0,x,y)>radius*radius)return false;const angle12=radiansToward(x0,y0,x,y);return coneAngle/2>=Math.abs(subtractRadians(direction,angle12))}var math=Object.freeze({randomInt:randomInt,randomInt2:randomInt2,randomFloat:randomFloat,randomFloat2:randomFloat2,randomCentered:randomCentered,randomNormal:randomNormal,isPowerOf2:isPowerOf2,nextPowerOf2:nextPowerOf2,mod:mod,wrap:wrap,clamp:clamp,between:between,lerp:lerp$1,lerpScale:lerpScale,radians:radians,degrees:degrees,heading:heading,angle:angle,subtractRadians:subtractRadians,subtractHeadings:subtractHeadings,radiansToward:radiansToward,headingToward:headingToward,distance:distance,sqDistance:sqDistance,inCone:inCone});function imagePromise(url){return new Promise((resolve,reject)=>{const img=new Image;img.crossOrigin="Anonymous";img.onload=(()=>resolve(img));img.onerror=(()=>reject(Error(`Could not load image ${url}`)));img.src=url})}function canvasBlobPromise(can,mimeType="image/png",quality=.95){return new Promise((resolve,reject)=>{can.toBlob(blob=>resolve(blob),mimeType,quality)})}function xhrPromise(url,type="text",method="GET"){return new Promise((resolve,reject)=>{const xhr=new XMLHttpRequest;xhr.open(method,url);xhr.responseType=type;xhr.onload=(()=>resolve(xhr.response));xhr.onerror=(()=>reject(Error(`Could not load ${url}: ${xhr.status}`)));xhr.send()})}function timeoutPromise(ms=1e3){return new Promise(resolve=>{setTimeout(resolve,ms)})}async function timeoutLoop(fcn,steps=-1,ms=0){let i=0;while(i++!==steps){fcn(i-1);await timeoutPromise(ms)}}function yieldLoop(fcn,steps=-1){let i=0;function*gen(){while(i++!==steps){yield fcn(i-1)}}const iterator=gen();while(!iterator.next().done){}}function rafPromise(){return new Promise(resolve=>requestAnimationFrame(resolve))}async function rafLoop(fcn,steps=-1){let i=0;while(i++!==steps){fcn(i-1);await rafPromise()}}function waitPromise(done,ms=10){return new Promise(resolve=>{function waitOn(){if(done())return resolve();else setTimeout(waitOn,ms)}waitOn()})}var async=Object.freeze({imagePromise:imagePromise,canvasBlobPromise:canvasBlobPromise,xhrPromise:xhrPromise,timeoutPromise:timeoutPromise,timeoutLoop:timeoutLoop,yieldLoop:yieldLoop,rafPromise:rafPromise,rafLoop:rafLoop,waitPromise:waitPromise});const identityFcn=o=>o;const noopFcn=()=>{};const propFcn=prop=>o=>o[prop];function nestedProperty(obj,path){if(typeof path==="string")path=path.split(".");switch(path.length){case 1:return obj[path[0]];case 2:return obj[path[0]][path[1]];case 3:return obj[path[0]][path[1]][path[2]];case 4:return obj[path[0]][path[1]][path[2]][path[3]];default:return path.reduce((obj,param)=>obj[param],obj)}}function repeat(n,f,a=[]){for(let i=0;i<n;i++)f(i,a);return a}function step(n,step,f){for(let i=0;i<n;i+=step)f(i)}function range(length){return repeat(length,(i,a)=>{a[i]=i})}const arrayMax=array=>array.reduce((a,b)=>Math.max(a,b));const arrayMin=array=>array.reduce((a,b)=>Math.min(a,b));const arrayExtent=array=>[objects.arrayMin(array),objects.arrayMax(array)];const arraySum=array=>array.reduce((a,b)=>a+b,0);function arraysEqual(a1,a2){if(a1.length!==a2.length)return false;for(let i=0;i<a1.length;i++){if(a1[i]!==a2[i])return false}return true}function removeArrayItem(array,item){const ix=array.indexOf(item);if(ix!==-1)array.splice(ix,1);else console.log(`removeArrayItem: ${item} not in array`);return array}const arraysToString=arrays=>arrays.map(a=>`${a}`).join(",");function forLoop(arrayOrObj,fcn){if(arrayOrObj.slice){for(let i=0,len=arrayOrObj.length;i<len;i++){fcn(arrayOrObj[i],i,arrayOrObj)}}else{Object.keys(arrayOrObj).forEach(k=>fcn(arrayOrObj[k],k,arrayOrObj))}}function clone(array){return array.slice(0)}function concatArrays(array1,array2){const Type=array1.constructor;if(Type===Array){return array1.concat(convertArrayType(array2,Array))}const array=new Type(array1.length+array2.length);array.set(array1);array.set(array2,array1.length);return array}const objectsEqual=(a,b)=>JSON.stringify(a)===JSON.stringify(b);function histogram(array,bins=10,min=arrayMin(array),max=arrayMax(array)){const binSize=(max-min)/bins;const hist=new Array(bins);hist.fill(0);forLoop(array,val=>{if(val<min||val>max){throw Error(`histogram bounds error: ${val}: ${min}-${max}`)}else{let bin=Math.floor((val-min)/binSize);if(bin===bins)bin--;hist[bin]++}});hist.parameters={bins:bins,min:min,max:max,binSize:binSize,arraySize:array.length};return hist}const oneOf=array=>array[randomInt(array.length)];function otherOneOf(array,item){if(array.length<2)throw Error("otherOneOf: array.length < 2");do{var other=oneOf(array)}while(item===other);return other}const oneKeyOf=obj=>oneOf(Object.keys(obj));const oneValOf=obj=>obj[oneKeyOf(obj)];function sortNums(array,ascending=true){return array.sort((a,b)=>ascending?a-b:b-a)}function sortObjs(array,fcn,ascending=true){if(typeof fcn==="string")fcn=propFcn(fcn);const comp=(a,b)=>fcn(a)-fcn(b);return array.sort((a,b)=>ascending?comp(a,b):-comp(a,b))}function shuffle(array){for(let i=array.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));const temp=array[i];array[i]=array[j];array[j]=temp}return array}function uniq(array,f=identityFcn){if(isString(f))f=propFcn(f);return array.filter((ai,i,a)=>i===0||f(ai)!==f(a[i-1]))}const uniqUnsorted=array=>Array.from(new Set(array));function floatRamp(start,stop,numItems){if(numItems<=1)throw Error("floatRamp: numItems must be > 1");const a=[];for(let i=0;i<numItems;i++){a.push(start+(stop-start)*(i/(numItems-1)))}return a}function integerRamp(start,stop,numItems=Math.abs(stop-start)+1){return floatRamp(start,stop,numItems).map(a=>Math.round(a))}function normalize(array,lo=0,hi=1){const[min,max]=[arrayMin(array),arrayMax(array)];const scale=1/(max-min);return array.map(n=>lerp(lo,hi,scale*(n-min)))}function normalize8(array){return new Uint8ClampedArray(normalize(array,-.5,255.5))}function normalizeInt(array,lo,hi){return normalize(array,lo,hi).map(n=>Math.round(n))}var objects$1=Object.freeze({identityFcn:identityFcn,noopFcn:noopFcn,propFcn:propFcn,nestedProperty:nestedProperty,repeat:repeat,step:step,range:range,arrayMax:arrayMax,arrayMin:arrayMin,arrayExtent:arrayExtent,arraySum:arraySum,arraysEqual:arraysEqual,removeArrayItem:removeArrayItem,arraysToString:arraysToString,forLoop:forLoop,clone:clone,concatArrays:concatArrays,objectsEqual:objectsEqual,histogram:histogram,oneOf:oneOf,otherOneOf:otherOneOf,oneKeyOf:oneKeyOf,oneValOf:oneValOf,sortNums:sortNums,sortObjs:sortObjs,shuffle:shuffle,uniq:uniq,uniqUnsorted:uniqUnsorted,floatRamp:floatRamp,integerRamp:integerRamp,normalize:normalize,normalize8:normalize8,normalizeInt:normalizeInt});function isOofA(data){if(!isObject(data))return false;return Object.values(data).every(v=>isTypedArray(v))}function toOofA(aofo,spec){const length=aofo.length;const keys=Object.keys(spec);const oofa={};keys.forEach(k=>{oofa[k]=new spec[k](length)});forLoop(aofo,(o,i)=>{keys.forEach(key=>oofa[key][i]=o[key])});return oofa}function oofaObject(oofa,i,keys){const obj={};keys.forEach(key=>{obj[key]=oofa[key][i]});return obj}function toAofO(oofa,keys=Object.keys(oofa)){const length=oofa[keys[0]].length;const aofo=new Array(length);forLoop(aofo,(val,i)=>{aofo[i]=oofaObject(oofa,i,keys)});return aofo}function oofaBuffers(postData){const buffers=[];forLoop(postData,obj=>forLoop(obj,a=>buffers.push(a.buffer)));return buffers}var oofa=Object.freeze({isOofA:isOofA,toOofA:toOofA,oofaObject:oofaObject,toAofO:toAofO,oofaBuffers:oofaBuffers});function parseQueryString(paramsString=window.location.search.substr(1)){const results={};const searchParams=new URLSearchParams(paramsString);for(var pair of searchParams.entries()){let[key,val]=pair;if(val.match(/^[0-9.]+$/))val=Number(val);if(["true","t",""].includes(val))val=true;if(["false","f"].includes(val))val=false;results[key]=val}return results}function setScript(path,props={}){const scriptTag=document.createElement("script");scriptTag.src=path;Object.assign(scriptTag,props);document.querySelector("head").appendChild(scriptTag)}function fcnToWorker(fcn){const href=document.location.href;const root=href.replace(/\/[^\/]+$/,"/");const fcnStr=`(${fcn.toString(root)})("${root}")`;const objUrl=URL.createObjectURL(new Blob([fcnStr],{type:"text/javascript"}));const worker=new Worker(objUrl);worker.onerror=function(e){console.log("ERROR: Line ",e.lineno,": ",e.message)};return worker}function workerScript(script,worker){const srcBlob=new Blob([script],{type:"text/javascript"});const srcURL=URL.createObjectURL(srcBlob);worker.postMessage({cmd:"script",url:srcURL})}function getEventXY(element,evt){const rect=element.getBoundingClientRect();return[evt.clientX-rect.left,evt.clientY-rect.top]}var dom=Object.freeze({parseQueryString:parseQueryString,setScript:setScript,fcnToWorker:fcnToWorker,workerScript:workerScript,getEventXY:getEventXY});const util={};Object.assign(util,canvas,debug,types,math,async,objects$1,oofa,dom);class AgentArray extends Array{static fromArray(array){Object.setPrototypeOf(array,AgentArray.prototype);return array}toArray(){Object.setPrototypeOf(this,Array.prototype);return this}isEmpty(){return this.length===0}first(){return this[0]}last(){return this[this.length-1]}props(key,type=AgentArray){const result=new type(this.length);for(let i=0;i<this.length;i++){result[i]=this[i][key]}return result}typedSample(obj){const result={};util.forLoop(obj,(val,key)=>{result[key]=this.props(key,val)});return result}results(fcn){const result=new AgentArray(this.length);for(let i=0;i<this.length;i++){result[i]=fcn(this[i])}return result}each(fcn){for(let i=0,len=this.length;i<len;i++){fcn(this[i],i,this)}}ask(fcn){const length=this.length;for(let i=0;i<Math.min(length,this.length);i++){fcn(this[i],i,this)}if(length!=this.length){const name=this.name||this.constructor.name;const direction=this.length<length?"decreasing":"increasing";util.warn(`AgentArray.ask array mutation: ${name}: ${direction}`)}}count(reporter){return this.reduce((prev,o)=>prev+(reporter(o)?1:0),0)}sum(key){return this.reduce((prev,o)=>prev+(key?o[key]:o),0)}avg(key){return this.sum(key)/this.length}min(key){return this.reduce((prev,o)=>Math.min(prev,key?o[key]:o),Infinity)}max(key){return this.reduce((prev,o)=>Math.max(prev,key?o[key]:o),-Infinity)}histogram(key,bins=10,min=this.min(key),max=this.max(key)){const binSize=(max-min)/bins;const aa=new AgentArray(bins);aa.fill(0);this.ask(a=>{const val=key?a[key]:a;if(val<min||val>max){util.warn(`histogram bounds error: ${val}: ${min}-${max}`)}else{let bin=Math.floor((val-min)/binSize);if(bin===bins)bin--;aa[bin]++}});aa.parameters={key:key,bins:bins,min:min,max:max,binSize:binSize,arraySize:this.length};return aa}cloneRange(begin=0,end=this.length){return this.slice(begin,end)}clone(){return this.slice(0)}shuffle(){return util.shuffle(this)}sortBy(reporter,ascending=true){util.sortObjs(this,reporter,ascending);return this}remove(o,f){const i=this.agentIndex(o,f);if(i!==-1)this.splice(i,1);else util.warn(`remove: ${o} not in AgentArray`);return this}insert(o,f){const i=this.sortedIndex(o,f);if(this[i]===o)throw Error("insert: item already in AgentArray");this.splice(i,0,o)}sortedIndex(item,f=util.identityFcn){if(util.isString(f))f=util.propFcn(f);const value=f(item);let low=0;let high=this.length;while(low<high){const mid=low+high>>>1;if(f(this[mid])<value){low=mid+1}else{high=mid}}return low}agentIndex(item,property){if(!property)return this.indexOf(item);const i=this.sortedIndex(item,property);return this[i]===item?i:-1}contains(item,f){return this.agentIndex(item,f)>=0}oneOf(){return util.oneOf(this)}otherOneOf(agent){return util.otherOneOf(this,agent)}otherNOf(n,item){if(this.length<n)throw Error("AgentArray: otherNOf: length < N");return this.clone().remove(item).shuffle().slice(0,n)}minOrMaxOf(min,reporter,valueToo=false){if(this.isEmpty())throw Error("min/max OneOf: empty array");if(typeof reporter==="string")reporter=util.propFcn(reporter);let o=null;let val=min?Infinity:-Infinity;for(let i=0;i<this.length;i++){const a=this[i];const aval=reporter(a);if(min&&aval<val||!min&&aval>val){[o,val]=[a,aval]}}return valueToo?[o,val]:o}minOneOf(reporter){return this.minOrMaxOf(true,reporter)}maxOneOf(reporter){return this.minOrMaxOf(false,reporter)}minValOf(reporter){return this.minOrMaxOf(true,reporter,true)}maxValOf(reporter){return this.minOrMaxOf(false,reporter,true)}nOf(n){if(n>this.length)throw Error("nOf: n larger than AgentArray");if(n===this.length)return this;const result=new AgentArray;while(result.length<n){const o=this.oneOf();if(!(o in result))result.push(o)}return result}minOrMaxNOf(min,n,reporter){if(n>this.length){throw Error("min/max nOf: n larger than AgentArray")}const as=this.clone().sortBy(reporter);return min?as.clone(0,n):as.clone(as.length-n)}minNOf(n,reporter){return this.minOrMaxNOf(true,n,reporter)}maxNOf(n,reporter){return this.minOrMaxNOf(false,n,reporter)}inRect(o,dx,dy=dx,meToo=false){const agents=new AgentArray;const minX=o.x-dx;const maxX=o.x+dx;const minY=o.y-dy;const maxY=o.y+dy;this.ask(a=>{if(minX<=a.x&&a.x<=maxX&&minY<=a.y&&a.y<=maxY){if(meToo||o!==a)agents.push(a)}});return agents}inRadius(o,radius,meToo=false){const agents=new AgentArray;const d2=radius*radius;const sqDistance=util.sqDistance;this.ask(a=>{if(sqDistance(o.x,o.y,a.x,a.y)<=d2){if(meToo||o!==a)agents.push(a)}});return agents}inCone(o,radius,coneAngle,direction,meToo=false){const agents=new AgentArray;this.ask(a=>{if(util.inCone(a.x,a.y,radius,coneAngle,direction,o.x,o.y)){if(meToo||o!==a)agents.push(a)}});return agents}}class AgentSet extends AgentArray{static get[Symbol.species](){return AgentArray}constructor(model,AgentClass,name,baseSet=null){super();baseSet=baseSet||this;Object.assign(this,{model:model,name:name,baseSet:baseSet,AgentClass:AgentClass});if(this.isBaseSet()){this.breeds={};this.ID=0}else{Object.setPrototypeOf(this,Object.getPrototypeOf(baseSet));this.baseSet.breeds[name]=this}this.ownVariables=[];this.agentProto=new AgentClass(this);this.protoMixin(this.agentProto,AgentClass)}protoMixin(agentProto,AgentClass){Object.assign(agentProto,{agentSet:this,model:this.model});agentProto[this.baseSet.name]=this.baseSet;if(!AgentClass.prototype.setBreed){Object.assign(AgentClass.prototype,{setBreed(breed){breed.setBreed(this)},getBreed(){return this.agentSet},isBreed(breed){return this.agentSet===breed}});Object.defineProperty(AgentClass.prototype,"breed",{get:function(){return this.agentSet}})}}newBreed(name){return new AgentSet(this.model,this.AgentClass,name,this)}isBreedSet(){return this.baseSet!==this}isBaseSet(){return this.baseSet===this}withBreed(breed){return this.filter(a=>a.agentSet===breed)}create(){console.log(`AgentSet: Abstract method called: ${this}`)}addAgent(o){o=o||Object.create(this.agentProto);if(this.isBreedSet())this.baseSet.addAgent(o);else o.id=this.ID++;this.push(o);return o}clear(){while(!this.isEmpty())this.last().die()}removeAgent(o){if(this.isBreedSet())this.baseSet.remove(o,"id");this.remove(o,"id");return this}setDefault(name,value){this.agentProto[name]=value;return this}getDefault(name){return this.agentProto[name]}settingDefault(agent){return agent.id==null}own(varnames){for(const name of varnames.split(" ")){this.setDefault(name,null);this.ownVariables.push(name)}}setBreed(a){if(a.agentSet===this)return;if(a.agentSet.isBreedSet())a.agentSet.remove(a,"id");if(this.isBreedSet())this.insert(a,"id");const avars=a.agentSet.ownVariables;for(const avar of avars){if(!this.ownVariables.includes(avar))delete a[avar]}for(const ownvar of this.ownVariables){if(!avars.includes(ownvar))a[ownvar]=0}return Object.setPrototypeOf(a,this.agentProto)}ask(fcn){if(this.length===0)return;const lastID=this.last().id;for(let i=0;i<this.length&&this[i].id<=lastID;i++){fcn(this[i],i,this)}}askSet(fcn){if(this.length===0)return;if(this.name==="patches")super.each(fcn);else if(this.isBaseSet())this.baseSetAsk(fcn);else if(this.isBreedSet())this.cloneAsk(fcn)}baseSetAsk(fcn){if(this.length===0)return;const lastID=this.last().id;for(let i=0;i<this.length;i++){const obj=this[i];const id=obj.id;if(id>lastID)break;fcn(obj,i,this);if(i>=this.length)break;if(this[i].id>id){while(i>=0&&this[i].id>id)i--}}}cloneAsk(fcn){const clone=this.clone();for(let i=0;i<clone.length;i++){const obj=clone[i];if(obj.breed==this&&obj.id>0){fcn(obj,i,clone)}}}propsArrays(keys,indexed=true){const result=indexed?{}:new AgentArray(this.length);if(util.isString(keys))keys=keys.split(" ");for(let i=0;i<this.length;i++){const vals=[];const agent=this[i];for(let j=0;j<keys.length;j++){vals.push(agent[keys[j]])}result[indexed?agent.id:i]=vals}return result}propsObjects(keys,indexed=true){const result=indexed?{}:new AgentArray(this.length);if(util.isString(keys))keys=keys.split(/,*  */);for(let i=0;i<this.length;i++){const vals={};const agent=this[i];for(let j=0;j<keys.length;j++){let key=keys[j],val;if(key.includes(":")){[key,val]=key.split(":");val=util.getNestedObject(agent,val)}else{if(key.includes(".")){throw Error("propsObjects: dot notation requires name:val: "+key)}val=agent[key]}if(util.typeOf(val)==="function")val=agent[val.name]();if(util.isArray(val)){if(util.isInteger(val[0].id)){if(val.ID){throw Error("propsObjects: value cannot be an AgentSet: "+key)}val=val.map(v=>v.id)}else{val=util.clone(val)}}else if(util.isObject(val)){if(util.isInteger(val.id)){val=val.id}else{val=Object.assign({},obj);util.forLoop(val,(v,key)=>{if(util.isInteger(v.id)){v[key]=v.id}})}}vals[key]=val}result[indexed?agent.id:i]=vals}return result}}class DataSet{static emptyDataSet(width,height,Type){return new DataSet(width,height,new Type(width*height))}constructor(width,height,data){if(data.length!==width*height){throw Error(`new DataSet length: ${data.length} !== ${width} * ${height}`)}Object.assign(this,{width:width,height:height,data:data})}setName(string){this.name=string;return this}getName(){return this.name?this.name:this.makeName()}makeName(){const{width:width,height:height}=this;const sum=util.arraySum(this.data).toFixed(2);return`${this.dataType().name}-${width}-${height}-${sum}`}checkXY(x,y){if(!this.inBounds(x,y)){throw Error(`DataSet: x,y out of range: ${x}, ${y}`)}}inBounds(x,y){return util.between(x,0,this.width-1)&&util.between(y,0,this.height-1)}dataType(){return this.data.constructor}type(){return this.constructor}toIndex(x,y){return x+y*this.width}toXY(i){return[i%this.width,Math.floor(i/this.width)]}getXY(x,y){return this.data[this.toIndex(x,y)]}setXY(x,y,num){this.data[this.toIndex(x,y)]=num}sample(x,y,useNearest=true){this.checkXY(x,y);return useNearest?this.nearest(x,y):this.bilinear(x,y)}nearest(x,y){return this.getXY(Math.round(x),Math.round(y))}bilinear(x,y){const x0=Math.floor(x);const y0=Math.floor(y);const i=this.toIndex(x0,y0);const w=this.width;const dx=x-x0;const dy=y-y0;const dx1=1-dx;const dy1=1-dy;const f00=this.data[i];const f10=this.data[i+1]||0;const f01=this.data[i+w]||0;const f11=this.data[i+1+w]||0;return f00*dx1*dy1+f10*dx*dy1+f01*dx1*dy+f11*dx*dy}copy(){return new DataSet(this.width,this.height,util.clone(this.data))}emptyDataSet(width,height,type=this.dataType()){return DataSet.emptyDataSet(width,height,type)}emptyArray(length){const Type=this.type();return new Type(length)}resample(width,height,useNearest=true,Type=Array){if(width===this.width&&height===this.height)return this.copy();const ds=DataSet.emptyDataSet(width,height,Type);const xScale=(this.width-1)/(width-1);const yScale=(this.height-1)/(height-1);for(let y=0;y<height;y++){for(let x=0;x<width;x++){ds.setXY(x,y,this.sample(x*xScale,y*yScale,useNearest))}}return ds}scale(min,max){const dsMin=this.min();const dsMax=this.max();const dsDelta=dsMax-dsMin;const delta=max-min;const m=delta/dsDelta;const b=min-m*dsMin;return this.map(x=>m*x+b)}subset(x,y,width,height){if(x+width>this.width||y+height>this.height){throw Error("DataSet.subSet: params out of range")}const ds=this.emptyDataSet(width,height);for(let i=0;i<width;i++){for(let j=0;j<height;j++){ds.setXY(i,j,this.getXY(i+x,j+y))}}return ds}map(f){return new DataSet(this.width,this.height,this.data.map(f))}col(x){const[w,h,data]=[this.width,this.height,this.data];if(x>=w)throw Error(`col: x out of range width: ${w} x: ${x}`);const colData=this.emptyArray(h);for(let i=0;i<h;i++)colData[i]=data[x+i*w];return colData}row(y){const[w,h]=[this.width,this.height];if(y>=h)throw Error(`row: y out of range height: ${h} x: ${y}`);return this.data.slice(y*w,(y+1)*w)}convertType(type){this.data=util.convertArrayType(this.data,type)}concatEast(ds){const[w,h]=[this.width,this.height];const[w1,h1]=[ds.width,ds.height];if(h!==h1)throw Error(`concatEast: heights not equal ${h}, ${h1}`);const ds1=this.emptyDataSet(w+w1,h);for(let x=0;x<h;x++){for(let y=0;y<w;y++){ds1.setXY(x,y,this.getXY(x,y))}}for(let x=0;x<h1;x++){for(let y=0;y<w1;y++){ds1.setXY(x+w,y,ds.getXY(x,y))}}return ds1}concatSouth(dataset){const[w,h,data]=[this.width,this.height,this.data];if(w!==dataset.width){throw Error(`concatSouth: widths not equal ${w}, ${dataset.width}`)}const data1=util.concatArrays(data,dataset.data);return new DataSet(w,h+dataset.height,data1)}transformCoords(x,y,tlx,tly,w,h){const xs=(x-tlx)*(this.width-1)/w;const ys=(tly-y)*(this.height-1)/h;return[xs,ys]}coordSample(x,y,tlx,tly,w,h,useNearest=true){const[xs,ys]=this.transformCoords(x,y,tlx,tly,w,h);return this.sample(xs,ys,useNearest)}neighborhood(x,y,array=[]){array.length=0;const clampNeeded=x===0||x===this.width-1||y===0||y===this.height-1;for(let dy=-1;dy<=+1;dy++){for(let dx=-1;dx<=+1;dx++){let x0=x+dx;let y0=y+dy;if(clampNeeded){x0=util.clamp(x0,0,this.width-1);y0=util.clamp(y0,0,this.height-1)}array.push(this.data[this.toIndex(x0,y0)])}}return array}convolve(kernel,factor=1,crop=false){const[x0,y0,h,w]=crop?[1,1,this.height-1,this.width-1]:[0,0,this.height,this.width];const newDS=this.emptyDataSet(w,h);const newData=newDS.data;let i=0;for(let y=y0;y<h;y++){for(let x=x0;x<w;x++){const nei=this.neighborhood(x,y);let sum2=0;for(let i2=0;i2<kernel.length;i2++){sum2=sum2+kernel[i2]*nei[i2]}newData[i++]=sum2*factor}}return newDS}dzdx(n=2,factor=1/8){return this.convolve([-1,0,1,-n,0,n,-1,0,1],factor)}dzdy(n=2,factor=1/8){return this.convolve([1,n,1,0,0,0,-1,-n,-1],factor)}laplace8(){return this.convolve([-1,-1,-1,-1,8,-1,-1,-1,-1])}laplace4(){return this.convolve([0,-1,0,-1,4,-1,0,-1,0])}blur(factor=.0625){return this.convolve([1,2,1,2,4,2,1,2,1],factor)}edge(){return this.convolve([1,1,1,1,-7,1,1,1,1])}slopeAndAspect(cellSize=1,posAngle=true){const dzdx=this.dzdx();const dzdy=this.dzdy();let[aspect,slope]=[[],[]];const[h,w]=[dzdx.height,dzdx.width];for(let y=0;y<h;y++){for(let x=0;x<w;x++){const[gx,gy]=[dzdx.getXY(x,y),dzdy.getXY(x,y)];slope.push(Math.atan(util.distance(0,0,gx,gy))/cellSize);let rad=Math.atan2(-gy,-gx);if(posAngle&&rad<0)rad+=2*Math.PI;aspect.push(rad)}}slope=new DataSet(w,h,slope);aspect=new DataSet(w,h,aspect);return{slope:slope,aspect:aspect,dzdx:dzdx,dzdy:dzdy}}max(){return util.arrayMax(this.data)}min(){return util.arrayMin(this.data)}equals(dataset){return this.width===dataset.width&&this.height===dataset.height&&util.arraysEqual(this.data,dataset.data)}}class Link{static defaultVariables(){return{end0:null,end1:null,width:1}}constructor(){Object.assign(this,Link.defaultVariables())}init(from,to){this.end0=from;this.end1=to;from.links.push(this);to.links.push(this)}die(){this.agentSet.removeAgent(this);util.removeArrayItem(this.end0.links,this);util.removeArrayItem(this.end1.links,this);this.id=-1}bothEnds(){return[this.end0,this.end1]}length(){return this.end0.distance(this.end1)}otherEnd(turtle){if(turtle===this.end0)return this.end1;if(turtle===this.end1)return this.end0;throw Error(`Link.otherEnd: turtle not a link turtle: ${turtle}`)}get x0(){return this.end0.x}get y0(){return this.end0.y}get z0(){return this.end0.z?this.end0.z:0}get x1(){return this.end1.x}get y1(){return this.end1.y}get z1(){return this.end1.z?this.end1.z:0}}class Links extends AgentSet{createOne(from,to,initFcn){const link=this.addAgent();link.init(from,to);initFcn(link);return link}create(from,to,initFcn=(link=>{})){if(!Array.isArray(to))return this.createOne(from,to,initFcn);return to.map(t=>{return this.createOne(from,t,initFcn)})}}const{PI:PI,atan:atan,atan2:atan2,cos:cos,floor:floor,log:log,pow:pow,sin:sin,sinh:sinh,sqrt:sqrt,tan:tan}=Math;const radians$1=degrees=>degrees*PI/180;const degrees$1=radians=>radians*180/PI;function nestedProperty$1(obj,path){if(typeof path==="string")path=path.split(".");return path.reduce((obj,param)=>obj[param],obj)}const gis={lon2x(lon,z){return floor((lon+180)/360*pow(2,z))},lat2y(lat,z){const latRads=radians$1(lat);return floor((1-log(tan(latRads)+1/cos(latRads))/PI)*pow(2,z-1))},lonlat2xy(lon,lat,z){return[this.lon2x(lon,z),this.lat2y(lat,z)]},x2lon(x,z){return x/pow(2,z)*360-180},y2lat(y,z){const rads=atan(sinh(PI-2*PI*y/pow(2,z)));return degrees$1(rads)},xy2lonlat(x,y,z){return[this.x2lon(x,z),this.y2lat(y,z)]},xy2bbox(x,y,z){const[lon0,lat0]=this.xy2lonlat(x,y,z);const[lon1,lat1]=this.xy2lonlat(x+1,y+1,z);return[[lon0,lat0],[lon1,lat1]]},getOsmURL(south,west,north,east){const url="https://overpass-api.de/api/interpreter?data=";const params=`[out:json][timeout:180][bbox:${south},${west},${north},${east}];\nway[highway];\n(._;>;);\nout;`;return url+encodeURIComponent(params)},lonLat2meters(pt1,pt2){const[lon1,lat1]=pt1.map(val=>radians$1(val));const[lon2,lat2]=pt2.map(val=>radians$1(val));const R=6378.137;const dLat=lat2-lat1;const dLon=lon2-lon1;const a=pow(sin(dLat/2),2)+cos(lat1)*cos(lat2)*sin(dLon/2)*sin(dLon/2);const c=2*atan2(sqrt(a),sqrt(1-a));const d=R*c;return d*1e3},cloneJson(json){return JSON.parse(JSON.stringify(json))},areEqual(json0,json1){return JSON.stringify(json0)===JSON.stringify(json1)},flattenMultiLineStrings(json){const features=[];json.features.forEach(feature=>{if(feature.geometry.type==="MultiLineString"){feature.geometry.coordinates.forEach(coords=>{const copy=Object.assign({},feature);copy.geometry.type="LineString";copy.geometry.coordinates=coords;features.push(copy)})}else{features.push(feature)}});json.features=features;return json},featureFilter(json,filterFcn){json.features=json.features.filter(filterFcn);return json},pathFilter(json,featurePath,values){if(typeof values==="string")values=values.split(" ");this.featureFilter(json,feature=>{const value=nestedProperty$1(feature,featurePath);return values.includes(value)});return json},geometryFilter(json,values){return this.pathFilter(json,"geometry.type",values)},propertiesFilter(json,properties){if(typeof properties==="string")properties=properties.split(" ");json.features.forEach(feature=>{const obj={};properties.forEach(prop=>{if(feature.properties[prop]!==undefined){obj[prop]=feature.properties[prop]}});feature.properties=obj});return json},streetTypes:["motorway","trunk","residential","primary","secondary","tertiary","motorway_link","trunk_link","primary_link","secondary_link","tertiary_link"],streetProperties:["highway","oneway","name","tiger:name_base"],streetsFilter(json,streetTypes=this.streetTypes,streetProperties=this.streetProperties){this.geometryFilter(json,"LineString");this.pathFilter(json,"properties.highway",streetTypes);this.propertiesFilter(json,streetProperties);return json},minify(json){const str=JSON.stringify(json);return str.replace(/,{"type":"Feature"/g,'\n,\n{"type":"Feature"')}};class World{static defaultOptions(maxX=16,maxY=maxX){return{minX:-maxX,maxX:maxX,minY:-maxY,maxY:maxY}}static defaultWorld(maxX=16,maxY=maxX){return new World(World.defaultOptions(maxX,maxY))}constructor(options={}){Object.assign(this,World.defaultOptions());Object.assign(this,options);this.setWorld()}setWorld(){this.numX=this.width=this.maxX-this.minX+1;this.numY=this.height=this.maxY-this.minY+1;this.minXcor=this.minX-.5;this.maxXcor=this.maxX+.5;this.minYcor=this.minY-.5;this.maxYcor=this.maxY+.5;this.centerX=(this.minX+this.maxX)/2;this.centerY=(this.minY+this.maxY)/2;this.numPatches=this.width*this.height}randomPosition(float=true){return float?[util.randomFloat2(this.minXcor,this.maxXcor),util.randomFloat2(this.minYcor,this.maxYcor)]:[util.randomInt2(this.minX,this.maxX),util.randomInt2(this.minY,this.maxY)]}isOnWorld(x,y){return this.minXcor<=x&&x<=this.maxXcor&&this.minYcor<=y&&y<=this.maxYcor}bboxTransform(topLeft,bottomRight){return new BBoxTransform(topLeft,bottomRight,this)}getWorldSize(patchSize=1){return[this.numX*patchSize,this.numY*patchSize]}setCtxTransform(ctx,patchSize){ctx.canvas.width=this.numX*patchSize;ctx.canvas.height=this.numY*patchSize;ctx.restore();ctx.save();ctx.scale(patchSize,-patchSize);ctx.translate(-this.minXcor,-this.maxYcor)}pixelXYtoPatchXY(x,y,patchSize){return[this.minXcor+x/patchSize,this.maxYcor-y/patchSize]}patchXYtoPixelXY(x,y,patchSize){return[(x-this.minXcor)*patchSize,(this.maxYcor-y)*patchSize]}setCanvasSize(canvas,patchSize){const[width,height]=this.getWorldSize(patchSize);util.setCanvasSize(canvas,width,height)}}class BBoxTransform{constructor(topLeft,bottomRight,world){let[topX,topY]=topLeft;let[botX,botY]=bottomRight;if(topX<botX)console.log("flipX");if(topY<botY)console.log("flipY");if(topX<botX)[topX,botX]=[botX,topX];if(topY<botY)[topY,botY]=[botY,topY];const{maxXcor:maxXcor,maxYcor:maxYcor,minXcor:minXcor,minYcor:minYcor}=world;const mx=(topX-botX)/(maxXcor-minXcor);const my=(topY-botY)/(maxYcor-minYcor);const bx=(topX+botX-mx*(maxXcor+minXcor))/2;const by=(topY+botY-my*(maxYcor+minYcor))/2;Object.assign(this,{mx:mx,my:my,bx:bx,by:by})}toWorld(tlbrPoint){const{mx:mx,my:my,bx:bx,by:by}=this;const[tlbrX,tlbrY]=tlbrPoint;const x=(tlbrX-bx)/mx;const y=(tlbrY-by)/my;return[x,y]}toBBox(worldPoint){const{mx:mx,my:my,bx:bx,by:by}=this;const[worldX,worldY]=worldPoint;const x=mx*worldX+bx;const y=my*worldY+by;return[x,y]}}class Patches extends AgentSet{constructor(model,AgentClass,name){super(model,AgentClass,name);if(this.isBreedSet())return;this.populate();this.labels=[]}populate(){util.repeat(this.model.world.numX*this.model.world.numY,i=>{this.addAgent()})}setDefault(name,value){if(name==="color"){this.ask(p=>{p.setColor(value)});util.logOnce("patches.setDefault(color, value): color default not supported. Clearing to value")}else{super.setDefault(name,value)}}setLabel(patch,label){if(label==null){delete this.labels[patch.id]}else{this.labels[patch.id]=label}}getLabel(patch){return this.labels[patch.id]}neighborsOffsets(x,y){const{minX:minX,maxX:maxX,minY:minY,maxY:maxY,numX:numX}=this.model.world;if(x===minX){if(y===minY)return[-numX,-numX+1,1];if(y===maxY)return[1,numX+1,numX];return[-numX,-numX+1,1,numX+1,numX]}if(x===maxX){if(y===minY)return[-numX-1,-numX,-1];if(y===maxY)return[numX,numX-1,-1];return[-numX-1,-numX,numX,numX-1,-1]}if(y===minY)return[-numX-1,-numX,-numX+1,1,-1];if(y===maxY)return[1,numX+1,numX,numX-1,-1];return[-numX-1,-numX,-numX+1,1,numX+1,numX,numX-1,-1]}neighbors4Offsets(x,y){const numX=this.model.world.numX;return this.neighborsOffsets(x,y).filter(n=>Math.abs(n)===1||Math.abs(n)===numX)}neighbors(patch){const{id:id,x:x,y:y}=patch;const offsets=this.neighborsOffsets(x,y);const as=new AgentArray(offsets.length);offsets.forEach((o,i)=>{as[i]=this[o+id]});return as}neighbors4(patch){const{id:id,x:x,y:y}=patch;const offsets=this.neighbors4Offsets(x,y);const as=new AgentArray(offsets.length);offsets.forEach((o,i)=>{as[i]=this[o+id]});return as}randomPt(){const{minX:minX,maxX:maxX,minY:minY,maxY:maxY}=this.model.world;return[util.randomInt2(minX,maxX),util.randomInt2(minY,maxY)]}importDataSet(dataSet,patchVar,useNearest=false){if(this.isBreedSet()){util.warn("Patches: exportDataSet called with breed, using patches");this.baseSet.importDataSet(dataSet,patchVar,useNearest);return}const{numX:numX,numY:numY}=this.model.world;const dataset=dataSet.resample(numX,numY,useNearest);this.ask(p=>{p[patchVar]=dataset.data[p.id]})}exportDataSet(patchVar,Type=Array){if(this.isBreedSet()){util.warn("Patches: exportDataSet called with breed, using patches");return this.baseSet.exportDataSet(patchVar,Type)}const{numX:numX,numY:numY}=this.model.world;let data=this.props(patchVar);data=util.convertArrayType(data,Type);return new DataSet(numX,numY,data)}patchIndex(x,y){const{minX:minX,maxY:maxY,numX:numX}=this.model.world;return x-minX+numX*(maxY-y)}patch(x,y){if(!this.model.world.isOnWorld(x,y))return undefined;const intX=x===this.model.world.maxXcor?this.model.world.maxX:Math.round(x);const intY=y===this.model.world.maxYcor?this.model.world.maxY:Math.round(y);return this.patchXY(intX,intY)}patchXY(x,y){return this[this.patchIndex(x,y)]}patchRect(p,dx,dy=dx,meToo=true){if(p.rectCache){const index=this.cacheIndex(dx,dy,meToo);const rect=p.rectCache[index];if(rect)return rect}const rect=new AgentArray;let{minX:minX,maxX:maxX,minY:minY,maxY:maxY}=this.model.world;minX=Math.max(minX,p.x-dx);maxX=Math.min(maxX,p.x+dx);minY=Math.max(minY,p.y-dy);maxY=Math.min(maxY,p.y+dy);for(let y=minY;y<=maxY;y++){for(let x=minX;x<=maxX;x++){const pnext=this.patchXY(x,y);if(p!==pnext||meToo)rect.push(pnext)}}return rect}patchRectXY(x,y,dx,dy=dx,meToo=true){return this.patchRect(this.patch(x,y),dx,dy,meToo)}cacheIndex(dx,dy=dx,meToo=true){return(2*dx+1)*(2*dy+1)+(meToo?0:-1)}cacheRect(dx,dy=dx,meToo=true,clear=true){const index=this.cacheIndex(dx,dy,meToo);this.ask(p=>{if(!p.rectCache||clear)p.rectCache=[];const rect=this.inRect(p,dx,dy,meToo);p.rectCache[index]=rect})}inRect(patch,dx,dy=dx,meToo=true){const pRect=this.patchRect(patch,dx,dy,meToo);if(this.isBaseSet())return pRect;return pRect.withBreed(this)}inRadius(patch,radius,meToo=true){const dxy=Math.ceil(radius);const pRect=this.inRect(patch,dxy,dxy,meToo);return pRect.inRadius(patch,radius,meToo)}inCone(patch,radius,coneAngle,direction,meToo=true){const dxy=Math.ceil(radius);const pRect=this.inRect(patch,dxy,dxy,meToo);return pRect.inCone(patch,radius,coneAngle,direction,meToo)}patchAtAngleAndDistance(obj,angle,distance){let{x:x,y:y}=obj;x=x+distance*Math.cos(angle);y=y+distance*Math.sin(angle);return this.patch(x,y)}isOnEdge(patch){const{x:x,y:y}=patch;const{minX:minX,maxX:maxX,minY:minY,maxY:maxY}=this.model.world;return x===minX||x===maxX||y===minY||y===maxY}edgePatches(){return this.filter(p=>this.isOnEdge(p))}diffuse(v,rate){this.diffuseN(8,v,rate)}diffuse4(v,rate){this.diffuseN(4,v,rate)}diffuseN(n,v,rate){if(this[0]._diffuseNext===undefined){for(let i=0;i<this.length;i++)this[i]._diffuseNext=0}for(let i=0;i<this.length;i++){const p=this[i];const dv=p[v]*rate;const dvn=dv/n;const neighbors=n===8?p.neighbors:p.neighbors4;const nn=neighbors.length;p._diffuseNext+=p[v]-dv+(n-nn)*dvn;for(let i=0;i<neighbors.length;i++){neighbors[i]._diffuseNext+=dvn}}for(let i=0;i<this.length;i++){const p=this[i];p[v]=p._diffuseNext;p._diffuseNext=0}}}class Patch{static defaultVariables(){return{turtles:undefined}}constructor(){Object.assign(this,Patch.defaultVariables())}get x(){return this.id%this.model.world.numX+this.model.world.minX}get y(){return this.model.world.maxY-Math.floor(this.id/this.model.world.numX)}isOnEdge(){return this.patches.isOnEdge(this)}get neighbors(){const n=this.patches.neighbors(this);Object.defineProperty(this,"neighbors",{value:n,enumerable:true});return n}get neighbors4(){const n=this.patches.neighbors4(this);Object.defineProperty(this,"neighbors4",{value:n,enumerable:true});return n}turtlesHere(){if(this.turtles==null){this.patches.ask(p=>{p.turtles=[]});this.model.turtles.ask(t=>{t.patch.turtles.push(t)})}return this.turtles}breedsHere(breed){const turtles=this.turtlesHere();return turtles.withBreed(breed)}distanceXY(x,y){return util.distance(this.x,this.y,x,y)}distance(agent){return this.distanceXY(agent.x,agent.y)}towards(agent){return this.towardsXY(agent.x,agent.y)}towardsXY(x,y){return util.radiansToward(this.x,this.y,x,y)}patchAt(dx,dy){return this.patches.patch(this.x+dx,this.y+dy)}patchAtAngleAndDistance(direction,distance){return this.patches.patchAtAngleAndDistance(this,direction,distance)}sprout(num=1,breed=this.model.turtles,initFcn=(turtle=>{})){return breed.create(num,turtle=>{turtle.setxy(this.x,this.y);initFcn(turtle)})}}class Turtles extends AgentSet{createOne(initFcn){const turtle=this.addAgent();turtle.theta=util.randomFloat(Math.PI*2);initFcn(turtle);return turtle}create(num=1,initFcn=(turtle=>{})){if(num===1)return this.createOne(initFcn);return util.repeat(num,(i,a)=>{const turtle=this.addAgent();turtle.theta=util.randomFloat(Math.PI*2);initFcn(turtle);a.push(turtle)})}randomPt(){const{minXcor:minXcor,maxXcor:maxXcor,minYcor:minYcor,maxYcor:maxYcor}=this.model.world;return[util.randomFloat2(minXcor,maxXcor),util.randomFloat2(minYcor,maxYcor)]}inPatches(patches){let array=new AgentArray;for(const p of patches)array.push(...p.turtlesHere());if(this.isBreedSet())array=array.filter(a=>a.agentSet===this);return array}inPatchRect(turtle,dx,dy=dx,meToo=false){const patches=this.model.patches.inRect(turtle.patch,dx,dy,true);const agents=this.inPatches(patches);if(!meToo)util.removeArrayItem(agents,turtle);return agents}inRadius(turtle,radius,meToo=false){const agents=this.inPatchRect(turtle,radius,radius,true);return agents.inRadius(turtle,radius,meToo)}inCone(turtle,radius,coneAngle,meToo=false){const agents=this.inPatchRect(turtle,radius,radius,true);return agents.inCone(turtle,radius,coneAngle,turtle.theta,meToo)}layoutCircle(radius,center=[0,0],startAngle=Math.PI/2,direction=-1){const dTheta=2*Math.PI/this.length;const[x0,y0]=center;this.ask((turtle,i)=>{turtle.setxy(x0,y0);turtle.theta=startAngle+direction*dTheta*i;turtle.forward(radius)})}}class Turtle{static defaultVariables(){return{x:0,y:0,z:0,theta:0,atEdge:"clamp"}}constructor(){Object.assign(this,Turtle.defaultVariables())}die(){this.agentSet.removeAgent(this);if(this.hasOwnProperty("links")){while(this.links.length>0)this.links[0].die()}if(this.patch.turtles!=null){util.removeArrayItem(this.patch.turtles,this)}this.id=-1}hatch(num=1,breed=this.agentSet,init=(turtle=>{})){return breed.create(num,turtle=>{turtle.setxy(this.x,this.y);for(const key of breed.ownVariables){if(turtle[key]==null)turtle[key]=this[key]}init(turtle)})}get links(){Object.defineProperty(this,"links",{value:new AgentArray(0),enumerable:true});return this.links}get patch(){return this.model.patches.patch(this.x,this.y)}get heading(){return util.heading(this.theta)}set heading(heading){this.theta=util.angle(heading)}get direction(){return this.theta}set direction(theta){this.theta=theta}setxy(x,y,z=null){const p0=this.patch;if(z!=null)this.z=z;if(this.model.world.isOnWorld(x,y)||this.atEdge==="OK"){this.x=x;this.y=y}else{this.handleEdge(x,y)}const p=this.patch;if(p&&p.turtles!=null&&p!==p0){if(p0)util.removeArrayItem(p0.turtles,this);p.turtles.push(this)}}handleEdge(x,y){if(util.isString(this.atEdge)){const{minXcor:minXcor,maxXcor:maxXcor,minYcor:minYcor,maxYcor:maxYcor}=this.model.world;if(this.atEdge==="wrap"){this.x=util.wrap(x,minXcor,maxXcor);this.y=util.wrap(y,minYcor,maxYcor)}else if(this.atEdge==="clamp"||this.atEdge==="bounce"){this.x=util.clamp(x,minXcor,maxXcor);this.y=util.clamp(y,minYcor,maxYcor);if(this.atEdge==="bounce"){if(this.x===minXcor||this.x===maxXcor){this.theta=Math.PI-this.theta}else{this.theta=-this.theta}}}else{throw Error(`turtle.handleEdge: bad atEdge: ${this.atEdge}`)}}else{this.atEdge(this)}}moveTo(agent){this.setxy(agent.x,agent.y)}forward(d){this.setxy(this.x+d*Math.cos(this.theta),this.y+d*Math.sin(this.theta))}rotate(rad){this.theta=util.mod(this.theta+rad,Math.PI*2)}right(rad){this.rotate(-rad)}left(rad){this.rotate(rad)}face(agent){this.theta=this.towards(agent)}faceXY(x,y){this.theta=this.towardsXY(x,y)}patchAhead(distance){return this.patchAtAngleAndDistance(this.theta,distance)}canMove(distance){return this.patchAhead(distance)!=null}patchLeftAndAhead(angle,distance){return this.patchAtAngleAndDistance(angle+this.theta,distance)}patchRightAndAhead(angle,distance){return this.patchAtAngleAndDistance(angle-this.theta,distance)}distanceXY(x,y){return util.distance(this.x,this.y,x,y)}distance(agent){return util.distance(this.x,this.y,agent.x,agent.y)}towards(agent){return this.towardsXY(agent.x,agent.y)}towardsXY(x,y){return util.radiansToward(this.x,this.y,x,y)}patchAt(dx,dy){return this.model.patches.patch(this.x+dx,this.y+dy)}patchAtAngleAndDistance(direction,distance){return this.model.patches.patchAtAngleAndDistance(this,direction,distance)}otherEnd(l){return l.end0===this?l.end1:l.end0}linkNeighbors(){return this.links.map(l=>this.otherEnd(l))}}class Model{constructor(worldOptions=World.defaultOptions()){this.worldOptions=worldOptions;this.resetModel()}initAgentSet(name,AgentsetClass,AgentClass){const agentset=new AgentsetClass(this,AgentClass,name);this[name]=agentset}resetModel(){this.ticks=0;this.world=new World(this.worldOptions);this.initAgentSet("patches",Patches,Patch);this.initAgentSet("turtles",Turtles,Turtle);this.initAgentSet("links",Links,Link)}reset(){this.resetModel()}tick(){this.ticks++}setup(){}step(){}patchBreeds(breedNames){for(const breedName of breedNames.split(" ")){this[breedName]=this.patches.newBreed(breedName)}}turtleBreeds(breedNames){for(const breedName of breedNames.split(" ")){this[breedName]=this.turtles.newBreed(breedName)}}linkBreeds(breedNames){for(const breedName of breedNames.split(" ")){this[breedName]=this.links.newBreed(breedName)}}}class RGBDataSet extends DataSet{static scaleFromMinMax(min,max){return(max-min)/(2**24-1)}constructor(img,min=0,scale=1,ArrayType=Float32Array){super(img.width,img.height,new ArrayType(img.width*img.height));const ctx=util.createCtx(img.width,img.height);util.fillCtxWithImage(ctx,img);const imgData=util.ctxImageData(ctx);const convertedData=this.data;for(var i=0;i<convertedData.length;i++){const r=imgData.data[4*i];const g=imgData.data[4*i+1];const b=imgData.data[4*i+2];convertedData[i]=min+(r*256*256+g*256+b)*scale}}}function testStartup(toWindowObj){util.toWindow(toWindowObj);const usingPuppeteer=navigator.userAgent==="Puppeteer";if(usingPuppeteer)util.randomSeed()}function testSetup(model){const{world:world,patches:patches,turtles:turtles,links:links}=model;util.printToPage("patches: "+patches.length);util.printToPage("turtles: "+turtles.length);util.printToPage("links: "+links.length);const breeds=Object.assign({},turtles.breeds,patches.breeds);util.forLoop(breeds,(val,key)=>{util.printToPage(key+": "+val.length)});util.toWindow({world:world,patches:patches,turtles:turtles,links:links,model:model})}function testDone(model,propsNames=[]){const usingPuppeteer=navigator.userAgent==="Puppeteer";util.printToPage("");util.printToPage("Done:");propsNames.forEach(name=>{let val=model[name];if(util.isArray(val))val=val.length;if(util.isFunction(val))val=model[name]();util.printToPage(`${name}: ${val}`)});util.printToPage(modelIO.sampleObj(model));if(usingPuppeteer){window.modelDone=model.modelDone=true;window.modelSample=model.modelSample=modelIO.sampleJSON(model)}}function toJSON(obj,indent=0,topLevelArrayOK=true){let firstCall=topLevelArrayOK;const blackList=["rectCache"];const json=JSON.stringify(obj,(key,val)=>{if(blackList.includes(key))return undefined;const isAgentArray=Array.isArray(val)&&val.length>0&&Number.isInteger(val[0].id);if(isAgentArray&&!firstCall){return val.map(v=>v.id)}firstCall=false;return val},indent);return json}function sampleObj(model){const obj={model:Object.keys(model),patches:model.patches.length,patch:model.patches.oneOf(),turtles:model.turtles.length,turtle:model.turtles.oneOf(),links:model.links.length,link:model.links.oneOf()};const json=toJSON(obj);return JSON.parse(json)}function sampleJSON(model,indent=0){return toJSON(sampleObj(model),indent)}exports.AgentArray=AgentArray;exports.AgentSet=AgentSet;exports.DataSet=DataSet;exports.Link=Link;exports.Links=Links;exports.gis=gis;exports.Model=Model;exports.Patch=Patch;exports.Patches=Patches;exports.RGBDataSet=RGBDataSet;exports.Turtle=Turtle;exports.Turtles=Turtles;exports.World=World;exports.util=util;exports.testStartup=testStartup;exports.testSetup=testSetup;exports.testDone=testDone;exports.toJSON=toJSON;exports.sampleObj=sampleObj;exports.sampleJSON=sampleJSON;Object.defineProperty(exports,"__esModule",{value:true})});
